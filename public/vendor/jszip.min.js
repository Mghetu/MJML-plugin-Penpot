(function (global) {
  "use strict";

  const textEncoder = new TextEncoder();

  const toUint8Array = (data) => {
    if (data instanceof Uint8Array) {
      return data;
    }
    if (data instanceof ArrayBuffer) {
      return new Uint8Array(data);
    }
    if (Array.isArray(data)) {
      return new Uint8Array(data);
    }
    return textEncoder.encode(String(data));
  };

  const crcTable = (() => {
    const table = new Uint32Array(256);
    for (let i = 0; i < 256; i += 1) {
      let c = i;
      for (let j = 0; j < 8; j += 1) {
        c = c & 1 ? 0xedb88320 ^ (c >>> 1) : c >>> 1;
      }
      table[i] = c >>> 0;
    }
    return table;
  })();

  const crc32 = (data) => {
    let crc = 0xffffffff;
    for (let i = 0; i < data.length; i += 1) {
      const byte = data[i];
      crc = crcTable[(crc ^ byte) & 0xff] ^ (crc >>> 8);
    }
    return (crc ^ 0xffffffff) >>> 0;
  };

  const writeUint16 = (value) => {
    const buffer = new Uint8Array(2);
    const view = new DataView(buffer.buffer);
    view.setUint16(0, value, true);
    return buffer;
  };

  const writeUint32 = (value) => {
    const buffer = new Uint8Array(4);
    const view = new DataView(buffer.buffer);
    view.setUint32(0, value, true);
    return buffer;
  };

  class JSZipFolder {
    constructor(zip, prefix) {
      this.zip = zip;
      this.prefix = prefix;
    }

    file(name, data, options) {
      return this.zip.file(this.prefix + name, data, options);
    }
  }

  class JSZip {
    constructor(prefix = "") {
      this.files = [];
      this.prefix = prefix;
    }

    file(name, data, options = {}) {
      const fileName = `${this.prefix}${name}`;
      const content = toUint8Array(data);
      this.files.push({
        name: fileName,
        data: content,
        options,
      });
      return this;
    }

    folder(name) {
      const prefix = `${this.prefix}${name.replace(/\/+$/, "")}/`;
      return new JSZipFolder(this, prefix);
    }

    async generateAsync({ type }) {
      const localFiles = [];
      const centralDirectory = [];
      let offset = 0;

      this.files.forEach((file) => {
        const nameBytes = textEncoder.encode(file.name);
        const data = file.data;
        const crc = crc32(data);

        const localHeader = new Uint8Array([
          0x50,
          0x4b,
          0x03,
          0x04,
          0x14,
          0x00,
          0x00,
          0x00,
          0x00,
          0x00,
          0x00,
          0x00,
          0x00,
          0x00,
        ]);

        const localParts = [
          localHeader,
          writeUint32(crc),
          writeUint32(data.length),
          writeUint32(data.length),
          writeUint16(nameBytes.length),
          writeUint16(0),
          nameBytes,
          data,
        ];

        const localSize = localParts.reduce((sum, part) => sum + part.length, 0);
        localFiles.push(...localParts);

        const centralHeader = new Uint8Array([
          0x50,
          0x4b,
          0x01,
          0x02,
          0x14,
          0x00,
          0x14,
          0x00,
          0x00,
          0x00,
          0x00,
          0x00,
          0x00,
          0x00,
          0x00,
          0x00,
        ]);

        const centralParts = [
          centralHeader,
          writeUint32(crc),
          writeUint32(data.length),
          writeUint32(data.length),
          writeUint16(nameBytes.length),
          writeUint16(0),
          writeUint16(0),
          writeUint16(0),
          writeUint16(0),
          writeUint32(0),
          writeUint32(offset),
          nameBytes,
        ];

        centralDirectory.push(...centralParts);
        offset += localSize;
      });

      const centralSize = centralDirectory.reduce((sum, part) => sum + part.length, 0);
      const endRecord = new Uint8Array([
        0x50,
        0x4b,
        0x05,
        0x06,
        0x00,
        0x00,
        0x00,
        0x00,
      ]);

      const endParts = [
        endRecord,
        writeUint16(this.files.length),
        writeUint16(this.files.length),
        writeUint32(centralSize),
        writeUint32(offset),
        writeUint16(0),
      ];

      const totalSize =
        localFiles.reduce((sum, part) => sum + part.length, 0) +
        centralSize +
        endParts.reduce((sum, part) => sum + part.length, 0);

      const output = new Uint8Array(totalSize);
      let cursor = 0;
      const append = (part) => {
        output.set(part, cursor);
        cursor += part.length;
      };

      localFiles.forEach(append);
      centralDirectory.forEach(append);
      endParts.forEach(append);

      if (type === "blob") {
        return new Blob([output], { type: "application/zip" });
      }

      return output;
    }
  }

  global.JSZip = JSZip;
})(typeof window !== "undefined" ? window : this);
